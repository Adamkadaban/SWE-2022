{"ast":null,"code":"import memoizeOne from \"memoize-one\";\nexport { default as merge } from \"lodash.merge\";\nexport { default as mergeWith } from \"lodash.mergewith\";\nexport { default as objectAssign } from \"object-assign\";\nexport function omit(object, keys) {\n  var result = {};\n\n  for (var _key in object) {\n    if (keys.includes(_key)) continue;\n    result[_key] = object[_key];\n  }\n\n  return result;\n}\nexport function pick(object, keys) {\n  var result = {};\n\n  for (var _key2 of keys) {\n    if (_key2 in object) {\n      result[_key2] = object[_key2];\n    }\n  }\n\n  return result;\n}\nexport function split(object, keys) {\n  var picked = {};\n  var omitted = {};\n\n  for (var _key3 in object) {\n    if (keys.includes(_key3)) {\n      picked[_key3] = object[_key3];\n    } else {\n      omitted[_key3] = object[_key3];\n    }\n  }\n\n  return [picked, omitted];\n}\n/**\n * Get value from a deeply nested object using a string path\n * @param obj - the object\n * @param path - the string path\n * @param def  - the fallback value\n */\n\nexport function get(obj, path, fallback, index) {\n  var _path$split, _path; //@ts-ignore\n\n\n  path = (_path$split = (_path = path) == null ? void 0 : _path.split == null ? void 0 : _path.split(\".\")) != null ? _path$split : [path];\n\n  for (index = 0; index < path.length; index++) {\n    obj = obj ? obj[path[index]] : undefined;\n  }\n\n  return obj === undefined ? fallback : obj;\n} // Just a memoized version of `get`\n\nexport var memoizedGet = memoizeOne(get);\n/**\n * Get value from deeply nested object, based on path\n * It returns the path value if not found in object\n *\n * @param path - the string path or value\n * @param scale - the string path or value\n */\n\nexport function getWithDefault(path, scale) {\n  return get(scale, path, path);\n}\n/**\n * Returns the items of an object that meet the condition specified in a callback function.\n *\n * @param object the object to loop through\n * @param fn The filter function\n */\n\nexport function objectFilter(object, fn) {\n  var result = {};\n\n  for (var _key4 in object) {\n    var _value = object[_key4];\n    var shouldPass = fn(_value, _key4, object);\n\n    if (shouldPass) {\n      result[_key4] = _value;\n    }\n  }\n\n  return result;\n}\nexport var filterUndefined = object => objectFilter(object, val => val !== null);\nexport var objectKeys = obj => Object.keys(obj);\n/**\n * Object.entries polyfill for Nodev10 compatibility\n */\n\nexport var fromEntries = entries => entries.reduce((carry, _ref) => {\n  var [key, value] = _ref;\n  carry[key] = value;\n  return carry;\n}, {});","map":{"version":3,"sources":["../../src/object.ts"],"names":["default","result","keys","object","key","picked","omitted","path","index","obj","memoizedGet","memoizeOne","get","value","shouldPass","fn","filterUndefined","objectFilter","val","objectKeys","Object","fromEntries","entries","carry"],"mappings":"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","sourcesContent":["import memoizeOne from \"memoize-one\"\nimport type { Omit, Dict } from \"./types\"\nexport { default as merge } from \"lodash.merge\"\nexport { default as mergeWith } from \"lodash.mergewith\"\nexport { default as objectAssign } from \"object-assign\"\n\nexport function omit<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result: Dict = {}\n\n  for (const key in object) {\n    if (keys.includes(key as any)) continue\n    result[key] = object[key]\n  }\n\n  return result as Omit<T, K>\n}\n\nexport function pick<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result = {} as { [P in K]: T[P] }\n  for (const key of keys) {\n    if (key in object) {\n      result[key] = object[key]\n    }\n  }\n  return result\n}\n\nexport function split<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const picked: Dict = {}\n  const omitted: Dict = {}\n\n  for (const key in object) {\n    if (keys.includes(key as T[K])) {\n      picked[key] = object[key]\n    } else {\n      omitted[key] = object[key]\n    }\n  }\n\n  return [picked, omitted] as [{ [P in K]: T[P] }, Omit<T, K>]\n}\n\n/**\n * Get value from a deeply nested object using a string path\n * @param obj - the object\n * @param path - the string path\n * @param def  - the fallback value\n */\nexport function get(\n  obj: any,\n  path: string | number,\n  fallback?: any,\n  index?: number,\n) {\n  //@ts-ignore\n  path = (path?.split?.(\".\") ?? [path]) as string\n  for (index = 0; index < path.length; index++) {\n    obj = obj ? obj[path[index]] : undefined\n  }\n  return obj === undefined ? fallback : obj\n}\n\n// Just a memoized version of `get`\nexport const memoizedGet = memoizeOne(get)\n\n/**\n * Get value from deeply nested object, based on path\n * It returns the path value if not found in object\n *\n * @param path - the string path or value\n * @param scale - the string path or value\n */\nexport function getWithDefault(path: any, scale: any) {\n  return get(scale, path, path)\n}\n\ntype FilterFn<T> = (value: any, key: string, object: T) => boolean\n\n/**\n * Returns the items of an object that meet the condition specified in a callback function.\n *\n * @param object the object to loop through\n * @param fn The filter function\n */\nexport function objectFilter<T extends Dict>(object: T, fn: FilterFn<T>) {\n  const result: Dict = {}\n\n  for (const key in object) {\n    const value = object[key]\n    const shouldPass = fn(value, key, object)\n\n    if (shouldPass) {\n      result[key] = value\n    }\n  }\n\n  return result\n}\n\nexport const filterUndefined = (object: Dict) =>\n  objectFilter(object, (val) => val !== null)\n\nexport const objectKeys = <T extends Dict>(obj: T) =>\n  (Object.keys(obj) as unknown) as (keyof T)[]\n\n/**\n * Object.entries polyfill for Nodev10 compatibility\n */\nexport const fromEntries = <T extends unknown>(entries: [string, any][]) =>\n  entries.reduce((carry, [key, value]) => {\n    carry[key] = value\n    return carry\n  }, {}) as T\n"]},"metadata":{},"sourceType":"module"}