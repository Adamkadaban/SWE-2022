{"ast":null,"code":"import _slicedToArray from \"/root/Desktop/SWE-2022/client/comments/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport { useDescendant, useDescendants } from \"@chakra-ui/descendant\";\nimport { useControllableState, useFocusEffect, useIds } from \"@chakra-ui/hooks\";\nimport { addItem, callAllHandlers, createContext, getNextIndex, getPrevIndex, isArray, mergeRefs, normalizeEventKey, removeItem } from \"@chakra-ui/utils\";\nimport { useCallback, useRef, useState } from \"react\";\nimport * as warn from \"./warning\";\n/**\n * useAccordion hook provides all the state and focus management logic\n * for accordion items.\n */\n\nexport function useAccordion(props) {\n  var onChange = props.onChange,\n      defaultIndex = props.defaultIndex,\n      indexProp = props.index,\n      allowMultiple = props.allowMultiple,\n      allowToggle = props.allowToggle,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"onChange\", \"defaultIndex\", \"index\", \"allowMultiple\", \"allowToggle\"]); // validate the props and `warn` if used incorrectly\n\n\n  warn.allowMultiple(props);\n  warn.allowMultipleAndAllowToggle(props);\n  /**\n   * Think of this as the register to each accordion item.\n   * We used to manage focus between accordion item buttons.\n   *\n   * Every accordion item, registers their button refs in this context\n   */\n\n  var domContext = useDescendants();\n  /**\n   * This state is used to track the index focused accordion\n   * button when click on the button, tab on the button, or\n   * use the down/up arrow to navigate.\n   */\n\n  var _useState = useState(-1),\n      _useState2 = _slicedToArray(_useState, 2),\n      focusedIndex = _useState2[0],\n      setFocusedIndex = _useState2[1];\n  /**\n   * Hook that manages the controlled and un-controlled state\n   * for the accordion.\n   */\n\n\n  var _useControllableState = useControllableState({\n    value: indexProp,\n    defaultValue: function defaultValue() {\n      if (allowMultiple) {\n        return defaultIndex != null ? defaultIndex : [];\n      } else {\n        return defaultIndex != null ? defaultIndex : -1;\n      }\n    },\n    onChange: onChange,\n    propsMap: {\n      value: \"index\",\n      defaultValue: \"defaultIndex\"\n    }\n  }),\n      _useControllableState2 = _slicedToArray(_useControllableState, 2),\n      index = _useControllableState2[0],\n      setIndex = _useControllableState2[1];\n  /**\n   * Gets the `isOpen` and `onChange` props for a child accordion item based on\n   * the child's index.\n   *\n   * @param idx {number} The index of the child accordion item\n   */\n\n\n  var getItemProps = function getItemProps(idx) {\n    var isOpen = isArray(index) ? index.includes(idx) : index === idx;\n\n    var onChange = function onChange(isOpen) {\n      if (allowMultiple && isArray(index)) {\n        var nextState = isOpen ? addItem(index, idx) : removeItem(index, idx);\n        setIndex(nextState);\n      } else {\n        if (isOpen) {\n          setIndex(idx);\n        } else if (allowToggle) {\n          setIndex(-1);\n        }\n      }\n    };\n\n    return {\n      isOpen: isOpen,\n      onChange: onChange\n    };\n  };\n\n  return {\n    htmlProps: htmlProps,\n    getItemProps: getItemProps,\n    focusedIndex: focusedIndex,\n    setFocusedIndex: setFocusedIndex,\n    domContext: domContext\n  };\n}\n\nvar _createContext = createContext({\n  name: \"AccordionContext\",\n  errorMessage: \"useAccordionContext: `context` is undefined. Seems you forgot to wrap the accordion components in `<Accordion />`\"\n}),\n    _createContext2 = _slicedToArray(_createContext, 2),\n    AccordionProvider = _createContext2[0],\n    useAccordionContext = _createContext2[1];\n\nexport { AccordionProvider, useAccordionContext };\n/**\n * useAccordionItem\n *\n * React hook that provides the open/close functionality\n * for an accordion item and it's children\n */\n\nexport function useAccordionItem(props) {\n  var isDisabled = props.isDisabled,\n      isFocusable = props.isFocusable,\n      id = props.id,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"isDisabled\", \"isFocusable\", \"id\"]);\n\n  var _useAccordionContext = useAccordionContext(),\n      getItemProps = _useAccordionContext.getItemProps,\n      domContext = _useAccordionContext.domContext,\n      focusedIndex = _useAccordionContext.focusedIndex,\n      setFocusedIndex = _useAccordionContext.setFocusedIndex;\n\n  var descendants = domContext.descendants;\n  var buttonRef = useRef(null);\n  /**\n   * Generate unique ids for all accordion item components (button and panel)\n   */\n\n  var _useIds = useIds(id, \"accordion-button\", \"accordion-panel\"),\n      _useIds2 = _slicedToArray(_useIds, 2),\n      buttonId = _useIds2[0],\n      panelId = _useIds2[1];\n\n  warn.focusableNotDisabled(props);\n  /**\n   * Think of this as a way to register this accordion item\n   * with it's parent `useAccordion`\n   */\n\n  var index = useDescendant({\n    element: buttonRef.current,\n    context: domContext,\n    disabled: isDisabled,\n    focusable: isFocusable\n  });\n\n  var _getItemProps = getItemProps(index),\n      isOpen = _getItemProps.isOpen,\n      onChange = _getItemProps.onChange;\n\n  var onOpen = function onOpen() {\n    onChange == null ? void 0 : onChange(true);\n  };\n\n  var onClose = function onClose() {\n    onChange == null ? void 0 : onChange(false);\n  };\n\n  var shouldFocus = index === focusedIndex;\n  /**\n   * Autofocus the accordion button when\n   * the active index matched the accordion item's index\n   */\n\n  useFocusEffect(buttonRef, {\n    shouldFocus: shouldFocus\n  });\n  /**\n   * Toggle the visibility of the accordion item\n   */\n\n  var onClick = useCallback(function () {\n    onChange == null ? void 0 : onChange(!isOpen);\n    setFocusedIndex(index);\n  }, [index, isOpen, onChange, setFocusedIndex]);\n  /**\n   * Manage keyboard navigation between accordion items.\n   */\n\n  var onKeyDown = useCallback(function (event) {\n    var eventKey = normalizeEventKey(event);\n    var keyMap = {\n      ArrowDown: function ArrowDown() {\n        var _nextAccordion$elemen;\n\n        var nextIndex = getNextIndex(index, descendants.length);\n        var nextAccordion = descendants[nextIndex];\n        nextAccordion == null ? void 0 : (_nextAccordion$elemen = nextAccordion.element) == null ? void 0 : _nextAccordion$elemen.focus();\n      },\n      ArrowUp: function ArrowUp() {\n        var _prevAccordion$elemen;\n\n        var prevIndex = getPrevIndex(index, descendants.length);\n        var prevAccordion = descendants[prevIndex];\n        prevAccordion == null ? void 0 : (_prevAccordion$elemen = prevAccordion.element) == null ? void 0 : _prevAccordion$elemen.focus();\n      },\n      Home: function Home() {\n        var _firstAccordion$eleme;\n\n        var firstAccordion = descendants[0];\n        firstAccordion == null ? void 0 : (_firstAccordion$eleme = firstAccordion.element) == null ? void 0 : _firstAccordion$eleme.focus();\n      },\n      End: function End() {\n        var _lastAccordion$elemen;\n\n        var lastAccordion = descendants[descendants.length - 1];\n        lastAccordion == null ? void 0 : (_lastAccordion$elemen = lastAccordion.element) == null ? void 0 : _lastAccordion$elemen.focus();\n      }\n    };\n    var action = keyMap[eventKey];\n\n    if (action) {\n      event.preventDefault();\n      action(event);\n    }\n  }, [descendants, index]);\n  /**\n   * Since each accordion item's button still remains tabbable, let's\n   * update the focusedIndex when it receives focus\n   */\n\n  var onFocus = useCallback(function () {\n    return setFocusedIndex(index);\n  }, [index, setFocusedIndex]);\n  var getButtonProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref: mergeRefs(buttonRef, ref),\n      id: buttonId,\n      disabled: !!isDisabled,\n      \"aria-expanded\": !!isOpen,\n      \"aria-controls\": panelId,\n      onClick: callAllHandlers(props.onClick, onClick),\n      onFocus: callAllHandlers(props.onFocus, onFocus),\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n    });\n  }, [buttonId, isDisabled, isOpen, onClick, onFocus, onKeyDown, panelId]);\n  var getPanelProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref: ref,\n      role: \"region\",\n      id: panelId,\n      \"aria-labelledby\": buttonId,\n      hidden: !isOpen\n    });\n  }, [buttonId, isOpen, panelId]);\n  return {\n    isOpen: isOpen,\n    isDisabled: isDisabled,\n    isFocusable: isFocusable,\n    onOpen: onOpen,\n    onClose: onClose,\n    getButtonProps: getButtonProps,\n    getPanelProps: getPanelProps,\n    htmlProps: htmlProps\n  };\n}","map":{"version":3,"sources":["../../src/use-accordion.ts"],"names":["index","allowToggle","warn","domContext","useDescendants","useState","useControllableState","value","defaultValue","defaultIndex","onChange","propsMap","getItemProps","idx","isOpen","isArray","allowMultiple","nextState","addItem","removeItem","setIndex","htmlProps","focusedIndex","setFocusedIndex","createContext","name","errorMessage","id","useAccordionContext","descendants","buttonRef","useRef","useIds","useDescendant","element","context","disabled","focusable","isFocusable","onOpen","onClose","shouldFocus","useFocusEffect","onClick","useCallback","onKeyDown","event","eventKey","normalizeEventKey","keyMap","ArrowDown","nextIndex","getNextIndex","nextAccordion","ArrowUp","prevIndex","getPrevIndex","prevAccordion","Home","firstAccordion","End","lastAccordion","action","onFocus","getButtonProps","props","ref","mergeRefs","callAllHandlers","getPanelProps","role","hidden","isDisabled"],"mappings":"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","sourcesContent":["import { useDescendant, useDescendants } from \"@chakra-ui/descendant\"\nimport { useControllableState, useFocusEffect, useIds } from \"@chakra-ui/hooks\"\nimport {\n  addItem,\n  callAllHandlers,\n  createContext,\n  EventKeyMap,\n  getNextIndex,\n  getPrevIndex,\n  isArray,\n  mergeRefs,\n  normalizeEventKey,\n  PropGetter,\n  removeItem,\n} from \"@chakra-ui/utils\"\nimport { useCallback, useRef, useState } from \"react\"\nimport * as warn from \"./warning\"\n\nexport type ExpandedIndex = number | number[]\n\nexport interface UseAccordionProps {\n  /**\n   * If `true`, multiple accordion items can be expanded at once.\n   */\n  allowMultiple?: boolean\n  /**\n   * If `true`, any expanded accordion item can be collapsed again.\n   */\n  allowToggle?: boolean\n  /**\n   * The index(es) of the expanded accordion item\n   */\n  index?: ExpandedIndex\n  /**\n   * The initial index(es) of the expanded accordion item\n   */\n  defaultIndex?: ExpandedIndex\n  /**\n   * The callback invoked when accordion items are expanded or collapsed.\n   */\n  onChange?: (expandedIndex: ExpandedIndex) => void\n}\n\n/**\n * useAccordion hook provides all the state and focus management logic\n * for accordion items.\n */\nexport function useAccordion(props: UseAccordionProps) {\n  const {\n    onChange,\n    defaultIndex,\n    index: indexProp,\n    allowMultiple,\n    allowToggle,\n    ...htmlProps\n  } = props\n\n  // validate the props and `warn` if used incorrectly\n  warn.allowMultiple(props)\n  warn.allowMultipleAndAllowToggle(props)\n\n  /**\n   * Think of this as the register to each accordion item.\n   * We used to manage focus between accordion item buttons.\n   *\n   * Every accordion item, registers their button refs in this context\n   */\n  const domContext = useDescendants()\n\n  /**\n   * This state is used to track the index focused accordion\n   * button when click on the button, tab on the button, or\n   * use the down/up arrow to navigate.\n   */\n  const [focusedIndex, setFocusedIndex] = useState(-1)\n\n  /**\n   * Hook that manages the controlled and un-controlled state\n   * for the accordion.\n   */\n  const [index, setIndex] = useControllableState({\n    value: indexProp,\n    defaultValue: () => {\n      if (allowMultiple) {\n        return defaultIndex ?? []\n      } else {\n        return defaultIndex ?? -1\n      }\n    },\n    onChange,\n    propsMap: {\n      value: \"index\",\n      defaultValue: \"defaultIndex\",\n    },\n  })\n\n  /**\n   * Gets the `isOpen` and `onChange` props for a child accordion item based on\n   * the child's index.\n   *\n   * @param idx {number} The index of the child accordion item\n   */\n  const getItemProps = (idx: number) => {\n    const isOpen = isArray(index) ? index.includes(idx) : index === idx\n    const onChange = (isOpen: boolean) => {\n      if (allowMultiple && isArray(index)) {\n        const nextState = isOpen ? addItem(index, idx) : removeItem(index, idx)\n        setIndex(nextState)\n      } else {\n        if (isOpen) {\n          setIndex(idx)\n        } else if (allowToggle) {\n          setIndex(-1)\n        }\n      }\n    }\n\n    return { isOpen, onChange }\n  }\n\n  return {\n    htmlProps,\n    getItemProps,\n    focusedIndex,\n    setFocusedIndex,\n    domContext,\n  }\n}\n\nexport type UseAccordionReturn = ReturnType<typeof useAccordion>\n\ninterface AccordionContext extends Omit<UseAccordionReturn, \"htmlProps\"> {\n  reduceMotion: boolean\n}\n\nconst [AccordionProvider, useAccordionContext] = createContext<\n  AccordionContext\n>({\n  name: \"AccordionContext\",\n  errorMessage:\n    \"useAccordionContext: `context` is undefined. Seems you forgot to wrap the accordion components in `<Accordion />`\",\n})\n\nexport { AccordionProvider, useAccordionContext }\n\nexport interface UseAccordionItemProps {\n  /**\n   * If `true`, the accordion item will be disabled.\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the accordion item will be focusable.\n   */\n  isFocusable?: boolean\n  /**\n   * A unique id for the accordion item.\n   */\n  id?: string\n}\n\n/**\n * useAccordionItem\n *\n * React hook that provides the open/close functionality\n * for an accordion item and it's children\n */\nexport function useAccordionItem(props: UseAccordionItemProps) {\n  const { isDisabled, isFocusable, id, ...htmlProps } = props\n\n  const {\n    getItemProps,\n    domContext,\n    focusedIndex,\n    setFocusedIndex,\n  } = useAccordionContext()\n  const { descendants } = domContext\n\n  const buttonRef = useRef<HTMLElement>(null)\n\n  /**\n   * Generate unique ids for all accordion item components (button and panel)\n   */\n  const [buttonId, panelId] = useIds(id, `accordion-button`, `accordion-panel`)\n\n  warn.focusableNotDisabled(props)\n\n  /**\n   * Think of this as a way to register this accordion item\n   * with it's parent `useAccordion`\n   */\n  const index = useDescendant({\n    element: buttonRef.current,\n    context: domContext,\n    disabled: isDisabled,\n    focusable: isFocusable,\n  })\n\n  const { isOpen, onChange } = getItemProps(index)\n\n  const onOpen = () => {\n    onChange?.(true)\n  }\n\n  const onClose = () => {\n    onChange?.(false)\n  }\n\n  const shouldFocus = index === focusedIndex\n\n  /**\n   * Autofocus the accordion button when\n   * the active index matched the accordion item's index\n   */\n  useFocusEffect(buttonRef, { shouldFocus })\n\n  /**\n   * Toggle the visibility of the accordion item\n   */\n  const onClick = useCallback(() => {\n    onChange?.(!isOpen)\n    setFocusedIndex(index)\n  }, [index, isOpen, onChange, setFocusedIndex])\n\n  /**\n   * Manage keyboard navigation between accordion items.\n   */\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = normalizeEventKey(event)\n\n      const keyMap: EventKeyMap = {\n        ArrowDown: () => {\n          const nextIndex = getNextIndex(index, descendants.length)\n          const nextAccordion = descendants[nextIndex]\n          nextAccordion?.element?.focus()\n        },\n        ArrowUp: () => {\n          const prevIndex = getPrevIndex(index, descendants.length)\n          const prevAccordion = descendants[prevIndex]\n          prevAccordion?.element?.focus()\n        },\n        Home: () => {\n          const firstAccordion = descendants[0]\n          firstAccordion?.element?.focus()\n        },\n        End: () => {\n          const lastAccordion = descendants[descendants.length - 1]\n          lastAccordion?.element?.focus()\n        },\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        action(event)\n      }\n    },\n    [descendants, index],\n  )\n\n  /**\n   * Since each accordion item's button still remains tabbable, let's\n   * update the focusedIndex when it receives focus\n   */\n  const onFocus = useCallback(() => setFocusedIndex(index), [\n    index,\n    setFocusedIndex,\n  ])\n\n  const getButtonProps: PropGetter<HTMLButtonElement> = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref: mergeRefs(buttonRef, ref),\n      id: buttonId,\n      disabled: !!isDisabled,\n      \"aria-expanded\": !!isOpen,\n      \"aria-controls\": panelId,\n      onClick: callAllHandlers(props.onClick, onClick),\n      onFocus: callAllHandlers(props.onFocus, onFocus),\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n    }),\n    [buttonId, isDisabled, isOpen, onClick, onFocus, onKeyDown, panelId],\n  )\n\n  const getPanelProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref,\n      role: \"region\",\n      id: panelId,\n      \"aria-labelledby\": buttonId,\n      hidden: !isOpen,\n    }),\n    [buttonId, isOpen, panelId],\n  )\n\n  return {\n    isOpen,\n    isDisabled,\n    isFocusable,\n    onOpen,\n    onClose,\n    getButtonProps,\n    getPanelProps,\n    htmlProps,\n  }\n}\n\nexport type UseAccordionItemReturn = ReturnType<typeof useAccordionItem>\n"]},"metadata":{},"sourceType":"module"}