{"ast":null,"code":"import { useUpdateEffect, useEventListener } from \"@chakra-ui/hooks\";\nimport { focus, getFirstTabbableIn, isFocusable } from \"@chakra-ui/utils\";\nimport { useRef } from \"react\";\n/**\n * Popover hook to manage the focus when the popover closes or hides.\n *\n * We either want to return focus back to the popover trigger or\n * let focus proceed normally if user moved to another interactive\n * element in the viewport.\n */\n\nexport function useFocusOnHide(popoverRef, options) {\n  var isFocusableRef = useRef(false);\n  var focusRef = options.focusRef,\n      autoFocus = options.autoFocus,\n      visible = options.visible,\n      trigger = options.trigger;\n  var shouldFocus = autoFocus && !visible && trigger === \"click\";\n\n  var onPointerDown = function onPointerDown(event) {\n    if (!options.visible) return;\n    var target = event.target;\n    var prevent = isFocusable(target) && target !== focusRef.current && !popoverRef.current.contains(target);\n\n    if (prevent) {\n      isFocusableRef.current = true;\n    }\n  };\n\n  useEventListener(\"mousedown\", onPointerDown);\n  useEventListener(\"touchstart\", onPointerDown);\n  useUpdateEffect(function () {\n    return function () {\n      if (!visible) {\n        isFocusableRef.current = false;\n      }\n    };\n  }, [visible]);\n  /**\n   * Using updateEffect here to allow effect to run only when\n   * `options.visible` changes, not on mount\n   */\n\n  useUpdateEffect(function () {\n    if (!shouldFocus || !popoverRef.current) return;\n    if (isFocusableRef.current) return;\n\n    if (focusRef.current) {\n      focus(focusRef.current);\n    }\n  }, [autoFocus, focusRef, visible, popoverRef, shouldFocus]);\n}\n/**\n * Popover hook to manage the focus when the popover opens.\n *\n * We either want to focus the popover content itself since it\n * has `tabIndex = -1`, or focus the first interactive element\n * within the popover content.\n */\n\nexport function useFocusOnShow(popoverRef, options) {\n  var visible = options.visible,\n      autoFocus = options.autoFocus,\n      focusRef = options.focusRef,\n      trigger = options.trigger;\n  /**\n   * Using updateEffect here to allow effect to run only when\n   * `options.visible` changes, not on mount\n   */\n\n  useUpdateEffect(function () {\n    if (trigger === \"hover\") return; // if `autoFocus` is false, move focus to the `PopoverContent`\n\n    if (!autoFocus && popoverRef.current) {\n      focus(popoverRef.current);\n      return;\n    }\n\n    var shouldFocus = visible && autoFocus;\n    if (!shouldFocus) return;\n\n    if (focusRef == null ? void 0 : focusRef.current) {\n      focus(focusRef.current);\n      return;\n    }\n\n    if (popoverRef.current) {\n      var firstTabbable = getFirstTabbableIn(popoverRef.current, true);\n      focus(firstTabbable != null ? firstTabbable : popoverRef.current);\n    }\n  }, [visible, autoFocus, popoverRef, focusRef]);\n}","map":{"version":3,"sources":["../../src/popover.utils.ts"],"names":["isFocusableRef","useRef","trigger","shouldFocus","autoFocus","onPointerDown","event","options","target","prevent","isFocusable","focusRef","popoverRef","useEventListener","useUpdateEffect","focus","visible","firstTabbable","getFirstTabbableIn"],"mappings":"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","sourcesContent":["import { useUpdateEffect, useEventListener } from \"@chakra-ui/hooks\"\nimport { focus, getFirstTabbableIn, isFocusable } from \"@chakra-ui/utils\"\nimport { RefObject, useRef } from \"react\"\n\nexport interface UseFocusOnHideOptions {\n  focusRef: RefObject<HTMLElement>\n  autoFocus?: boolean\n  visible?: boolean\n  trigger?: \"hover\" | \"click\"\n}\n\n/**\n * Popover hook to manage the focus when the popover closes or hides.\n *\n * We either want to return focus back to the popover trigger or\n * let focus proceed normally if user moved to another interactive\n * element in the viewport.\n */\nexport function useFocusOnHide(\n  popoverRef: RefObject<HTMLElement>,\n  options: UseFocusOnHideOptions,\n) {\n  const isFocusableRef = useRef(false)\n  const { focusRef, autoFocus, visible, trigger } = options\n\n  const shouldFocus = autoFocus && !visible && trigger === \"click\"\n\n  const onPointerDown = (event: MouseEvent) => {\n    if (!options.visible) return\n    const target = event.target as HTMLElement\n\n    const prevent =\n      isFocusable(target) &&\n      target !== focusRef.current &&\n      !(popoverRef.current as HTMLElement).contains(target)\n\n    if (prevent) {\n      isFocusableRef.current = true\n    }\n  }\n\n  useEventListener(\"mousedown\", onPointerDown)\n  useEventListener(\"touchstart\", onPointerDown)\n\n  useUpdateEffect(() => {\n    return () => {\n      if (!visible) {\n        isFocusableRef.current = false\n      }\n    }\n  }, [visible])\n\n  /**\n   * Using updateEffect here to allow effect to run only when\n   * `options.visible` changes, not on mount\n   */\n  useUpdateEffect(() => {\n    if (!shouldFocus || !popoverRef.current) return\n\n    if (isFocusableRef.current) return\n\n    if (focusRef.current) {\n      focus(focusRef.current)\n    }\n  }, [autoFocus, focusRef, visible, popoverRef, shouldFocus])\n}\n\ninterface UseFocusOnShowOptions {\n  autoFocus?: boolean\n  visible?: boolean\n  focusRef?: RefObject<HTMLElement>\n  trigger?: \"hover\" | \"click\"\n}\n\n/**\n * Popover hook to manage the focus when the popover opens.\n *\n * We either want to focus the popover content itself since it\n * has `tabIndex = -1`, or focus the first interactive element\n * within the popover content.\n */\nexport function useFocusOnShow(\n  popoverRef: RefObject<HTMLElement>,\n  options: UseFocusOnShowOptions,\n) {\n  const { visible, autoFocus, focusRef, trigger } = options\n\n  /**\n   * Using updateEffect here to allow effect to run only when\n   * `options.visible` changes, not on mount\n   */\n  useUpdateEffect(() => {\n    if (trigger === \"hover\") return\n\n    // if `autoFocus` is false, move focus to the `PopoverContent`\n    if (!autoFocus && popoverRef.current) {\n      focus(popoverRef.current)\n      return\n    }\n\n    const shouldFocus = visible && autoFocus\n\n    if (!shouldFocus) return\n\n    if (focusRef?.current) {\n      focus(focusRef.current)\n      return\n    }\n\n    if (popoverRef.current) {\n      const firstTabbable = getFirstTabbableIn(popoverRef.current, true)\n      focus(firstTabbable ?? popoverRef.current)\n    }\n  }, [visible, autoFocus, popoverRef, focusRef])\n}\n"]},"metadata":{},"sourceType":"module"}