function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import { useDescendant, useDescendants } from "@chakra-ui/descendant";
import { useControllableState, useFocusEffect, useIds } from "@chakra-ui/hooks";
import { addItem, callAllHandlers, createContext, getNextIndex, getPrevIndex, isArray, mergeRefs, normalizeEventKey, removeItem } from "@chakra-ui/utils";
import { useCallback, useRef, useState } from "react";
import * as warn from "./warning";

/**
 * useAccordion hook provides all the state and focus management logic
 * for accordion items.
 */
export function useAccordion(props) {
  var {
    onChange,
    defaultIndex,
    index: indexProp,
    allowMultiple,
    allowToggle
  } = props,
      htmlProps = _objectWithoutPropertiesLoose(props, ["onChange", "defaultIndex", "index", "allowMultiple", "allowToggle"]); // validate the props and `warn` if used incorrectly


  warn.allowMultiple(props);
  warn.allowMultipleAndAllowToggle(props);
  /**
   * Think of this as the register to each accordion item.
   * We used to manage focus between accordion item buttons.
   *
   * Every accordion item, registers their button refs in this context
   */

  var domContext = useDescendants();
  /**
   * This state is used to track the index focused accordion
   * button when click on the button, tab on the button, or
   * use the down/up arrow to navigate.
   */

  var [focusedIndex, setFocusedIndex] = useState(-1);
  /**
   * Hook that manages the controlled and un-controlled state
   * for the accordion.
   */

  var [index, setIndex] = useControllableState({
    value: indexProp,
    defaultValue: () => {
      if (allowMultiple) {
        return defaultIndex != null ? defaultIndex : [];
      } else {
        return defaultIndex != null ? defaultIndex : -1;
      }
    },
    onChange,
    propsMap: {
      value: "index",
      defaultValue: "defaultIndex"
    }
  });
  /**
   * Gets the `isOpen` and `onChange` props for a child accordion item based on
   * the child's index.
   *
   * @param idx {number} The index of the child accordion item
   */

  var getItemProps = idx => {
    var isOpen = isArray(index) ? index.includes(idx) : index === idx;

    var onChange = isOpen => {
      if (allowMultiple && isArray(index)) {
        var nextState = isOpen ? addItem(index, idx) : removeItem(index, idx);
        setIndex(nextState);
      } else {
        if (isOpen) {
          setIndex(idx);
        } else if (allowToggle) {
          setIndex(-1);
        }
      }
    };

    return {
      isOpen,
      onChange
    };
  };

  return {
    htmlProps,
    getItemProps,
    focusedIndex,
    setFocusedIndex,
    domContext
  };
}
var [AccordionProvider, useAccordionContext] = createContext({
  name: "AccordionContext",
  errorMessage: "useAccordionContext: `context` is undefined. Seems you forgot to wrap the accordion components in `<Accordion />`"
});
export { AccordionProvider, useAccordionContext };

/**
 * useAccordionItem
 *
 * React hook that provides the open/close functionality
 * for an accordion item and it's children
 */
export function useAccordionItem(props) {
  var {
    isDisabled,
    isFocusable,
    id
  } = props,
      htmlProps = _objectWithoutPropertiesLoose(props, ["isDisabled", "isFocusable", "id"]);

  var {
    getItemProps,
    domContext,
    focusedIndex,
    setFocusedIndex
  } = useAccordionContext();
  var {
    descendants
  } = domContext;
  var buttonRef = useRef(null);
  /**
   * Generate unique ids for all accordion item components (button and panel)
   */

  var [buttonId, panelId] = useIds(id, "accordion-button", "accordion-panel");
  warn.focusableNotDisabled(props);
  /**
   * Think of this as a way to register this accordion item
   * with it's parent `useAccordion`
   */

  var index = useDescendant({
    element: buttonRef.current,
    context: domContext,
    disabled: isDisabled,
    focusable: isFocusable
  });
  var {
    isOpen,
    onChange
  } = getItemProps(index);

  var onOpen = () => {
    onChange == null ? void 0 : onChange(true);
  };

  var onClose = () => {
    onChange == null ? void 0 : onChange(false);
  };

  var shouldFocus = index === focusedIndex;
  /**
   * Autofocus the accordion button when
   * the active index matched the accordion item's index
   */

  useFocusEffect(buttonRef, {
    shouldFocus
  });
  /**
   * Toggle the visibility of the accordion item
   */

  var onClick = useCallback(() => {
    onChange == null ? void 0 : onChange(!isOpen);
    setFocusedIndex(index);
  }, [index, isOpen, onChange, setFocusedIndex]);
  /**
   * Manage keyboard navigation between accordion items.
   */

  var onKeyDown = useCallback(event => {
    var eventKey = normalizeEventKey(event);
    var keyMap = {
      ArrowDown: () => {
        var _nextAccordion$elemen;

        var nextIndex = getNextIndex(index, descendants.length);
        var nextAccordion = descendants[nextIndex];
        nextAccordion == null ? void 0 : (_nextAccordion$elemen = nextAccordion.element) == null ? void 0 : _nextAccordion$elemen.focus();
      },
      ArrowUp: () => {
        var _prevAccordion$elemen;

        var prevIndex = getPrevIndex(index, descendants.length);
        var prevAccordion = descendants[prevIndex];
        prevAccordion == null ? void 0 : (_prevAccordion$elemen = prevAccordion.element) == null ? void 0 : _prevAccordion$elemen.focus();
      },
      Home: () => {
        var _firstAccordion$eleme;

        var firstAccordion = descendants[0];
        firstAccordion == null ? void 0 : (_firstAccordion$eleme = firstAccordion.element) == null ? void 0 : _firstAccordion$eleme.focus();
      },
      End: () => {
        var _lastAccordion$elemen;

        var lastAccordion = descendants[descendants.length - 1];
        lastAccordion == null ? void 0 : (_lastAccordion$elemen = lastAccordion.element) == null ? void 0 : _lastAccordion$elemen.focus();
      }
    };
    var action = keyMap[eventKey];

    if (action) {
      event.preventDefault();
      action(event);
    }
  }, [descendants, index]);
  /**
   * Since each accordion item's button still remains tabbable, let's
   * update the focusedIndex when it receives focus
   */

  var onFocus = useCallback(() => setFocusedIndex(index), [index, setFocusedIndex]);
  var getButtonProps = useCallback(function (props, ref) {
    if (props === void 0) {
      props = {};
    }

    if (ref === void 0) {
      ref = null;
    }

    return _extends({}, props, {
      ref: mergeRefs(buttonRef, ref),
      id: buttonId,
      disabled: !!isDisabled,
      "aria-expanded": !!isOpen,
      "aria-controls": panelId,
      onClick: callAllHandlers(props.onClick, onClick),
      onFocus: callAllHandlers(props.onFocus, onFocus),
      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)
    });
  }, [buttonId, isDisabled, isOpen, onClick, onFocus, onKeyDown, panelId]);
  var getPanelProps = useCallback(function (props, ref) {
    if (props === void 0) {
      props = {};
    }

    if (ref === void 0) {
      ref = null;
    }

    return _extends({}, props, {
      ref,
      role: "region",
      id: panelId,
      "aria-labelledby": buttonId,
      hidden: !isOpen
    });
  }, [buttonId, isOpen, panelId]);
  return {
    isOpen,
    isDisabled,
    isFocusable,
    onOpen,
    onClose,
    getButtonProps,
    getPanelProps,
    htmlProps
  };
}
//# sourceMappingURL=use-accordion.js.map