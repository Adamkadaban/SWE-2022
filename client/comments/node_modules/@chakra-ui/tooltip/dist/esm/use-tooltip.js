function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import { useDisclosure, useEventListener, useId } from "@chakra-ui/hooks";
import { usePopper } from "@chakra-ui/popper";
import { callAllHandlers, mergeRefs } from "@chakra-ui/utils";
import { useCallback, useEffect, useRef } from "react";
export function useTooltip(props) {
  if (props === void 0) {
    props = {};
  }

  var {
    openDelay = 0,
    closeDelay = 0,
    closeOnClick = true,
    closeOnMouseDown,
    onOpen: onOpenProp,
    onClose: onCloseProp,
    placement,
    id,
    isOpen: isOpenProp,
    defaultIsOpen,
    arrowSize = 10,
    modifiers,
    isDisabled,
    gutter,
    offset
  } = props,
      htmlProps = _objectWithoutPropertiesLoose(props, ["openDelay", "closeDelay", "closeOnClick", "closeOnMouseDown", "onOpen", "onClose", "placement", "id", "isOpen", "defaultIsOpen", "arrowSize", "modifiers", "isDisabled", "gutter", "offset"]);

  var {
    isOpen,
    onOpen,
    onClose
  } = useDisclosure({
    isOpen: isOpenProp,
    defaultIsOpen,
    onOpen: onOpenProp,
    onClose: onCloseProp
  });
  var popper = usePopper({
    forceUpdate: isOpen,
    placement,
    arrowSize,
    modifiers,
    gutter,
    offset
  });
  var tooltipId = useId(id, "tooltip");
  var ref = useRef(null);
  var triggerRef = mergeRefs(ref, popper.reference.ref);
  var enterTimeout = useRef();
  var exitTimeout = useRef();
  var openWithDelay = useCallback(() => {
    if (!isDisabled) {
      enterTimeout.current = window.setTimeout(onOpen, openDelay);
    }
  }, [isDisabled, onOpen, openDelay]);
  var closeWithDelay = useCallback(() => {
    if (enterTimeout.current) {
      clearTimeout(enterTimeout.current);
    }

    exitTimeout.current = window.setTimeout(onClose, closeDelay);
  }, [closeDelay, onClose]);
  var onClick = useCallback(() => {
    if (closeOnClick) {
      closeWithDelay();
    }
  }, [closeOnClick, closeWithDelay]);
  var onMouseDown = useCallback(() => {
    if (closeOnMouseDown) {
      closeWithDelay();
    }
  }, [closeOnMouseDown, closeWithDelay]);

  var onKeyDown = event => {
    if (isOpen && event.key === "Escape") {
      closeWithDelay();
    }
  };

  useEventListener("keydown", onKeyDown);
  useEffect(() => {
    return () => {
      clearTimeout(enterTimeout.current);
      clearTimeout(exitTimeout.current);
    };
  }, []);
  var getTriggerProps = useCallback(function (props, ref) {
    if (props === void 0) {
      props = {};
    }

    if (ref === void 0) {
      ref = null;
    }

    return _extends({}, props, {
      ref: mergeRefs(ref, triggerRef),
      onMouseLeave: callAllHandlers(props.onMouseLeave, closeWithDelay),
      onMouseEnter: callAllHandlers(props.onMouseEnter, openWithDelay),
      onClick: callAllHandlers(props.onClick, onClick),
      onMouseDown: callAllHandlers(props.onMouseDown, onMouseDown),
      onFocus: callAllHandlers(props.onFocus, openWithDelay),
      onBlur: callAllHandlers(props.onBlur, closeWithDelay),
      "aria-describedby": isOpen ? tooltipId : undefined
    });
  }, [closeWithDelay, isOpen, onClick, onMouseDown, openWithDelay, tooltipId, triggerRef]);
  var getTooltipProps = useCallback(function (props, ref) {
    if (props === void 0) {
      props = {};
    }

    if (ref === void 0) {
      ref = null;
    }

    return _extends({}, htmlProps, props, {
      id: tooltipId,
      role: "tooltip",
      ref: mergeRefs(ref, popper.popper.ref),
      style: _extends({}, props.style, popper.popper.style)
    });
  }, [htmlProps, popper.popper.ref, popper.popper.style, tooltipId]);
  var getArrowProps = useCallback(function (props, ref) {
    if (props === void 0) {
      props = {};
    }

    if (ref === void 0) {
      ref = null;
    }

    return _extends({}, props, {
      ref: mergeRefs(ref, popper.arrow.ref),
      style: _extends({}, props.style, popper.arrow.style)
    });
  }, [popper.arrow.ref, popper.arrow.style]);
  return {
    isOpen,
    show: openWithDelay,
    hide: closeWithDelay,
    placement: popper.placement,
    getTriggerProps,
    getTooltipProps,
    getArrowProps
  };
}
//# sourceMappingURL=use-tooltip.js.map