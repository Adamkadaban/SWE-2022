"use strict";

exports.__esModule = true;
exports.omit = omit;
exports.pick = pick;
exports.split = split;
exports.get = get;
exports.getWithDefault = getWithDefault;
exports.objectFilter = objectFilter;
exports.fromEntries = exports.objectKeys = exports.filterUndefined = exports.memoizedGet = exports.objectAssign = exports.mergeWith = exports.merge = void 0;

var _memoizeOne = _interopRequireDefault(require("memoize-one"));

var _lodash = _interopRequireDefault(require("lodash.merge"));

exports.merge = _lodash["default"];

var _lodash2 = _interopRequireDefault(require("lodash.mergewith"));

exports.mergeWith = _lodash2["default"];

var _objectAssign = _interopRequireDefault(require("object-assign"));

exports.objectAssign = _objectAssign["default"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function omit(object, keys) {
  var result = {};

  for (var _key in object) {
    if (keys.includes(_key)) continue;
    result[_key] = object[_key];
  }

  return result;
}

function pick(object, keys) {
  var result = {};

  for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
    var _key2 = _step.value;

    if (_key2 in object) {
      result[_key2] = object[_key2];
    }
  }

  return result;
}

function split(object, keys) {
  var picked = {};
  var omitted = {};

  for (var _key3 in object) {
    if (keys.includes(_key3)) {
      picked[_key3] = object[_key3];
    } else {
      omitted[_key3] = object[_key3];
    }
  }

  return [picked, omitted];
}
/**
 * Get value from a deeply nested object using a string path
 * @param obj - the object
 * @param path - the string path
 * @param def  - the fallback value
 */


function get(obj, path, fallback, index) {
  var _path$split, _path;

  //@ts-ignore
  path = (_path$split = (_path = path) == null ? void 0 : _path.split == null ? void 0 : _path.split(".")) != null ? _path$split : [path];

  for (index = 0; index < path.length; index++) {
    obj = obj ? obj[path[index]] : undefined;
  }

  return obj === undefined ? fallback : obj;
} // Just a memoized version of `get`


var memoizedGet = (0, _memoizeOne["default"])(get);
/**
 * Get value from deeply nested object, based on path
 * It returns the path value if not found in object
 *
 * @param path - the string path or value
 * @param scale - the string path or value
 */

exports.memoizedGet = memoizedGet;

function getWithDefault(path, scale) {
  return get(scale, path, path);
}

/**
 * Returns the items of an object that meet the condition specified in a callback function.
 *
 * @param object the object to loop through
 * @param fn The filter function
 */
function objectFilter(object, fn) {
  var result = {};

  for (var _key4 in object) {
    var _value = object[_key4];
    var shouldPass = fn(_value, _key4, object);

    if (shouldPass) {
      result[_key4] = _value;
    }
  }

  return result;
}

var filterUndefined = function filterUndefined(object) {
  return objectFilter(object, function (val) {
    return val !== null;
  });
};

exports.filterUndefined = filterUndefined;

var objectKeys = function objectKeys(obj) {
  return Object.keys(obj);
};
/**
 * Object.entries polyfill for Nodev10 compatibility
 */


exports.objectKeys = objectKeys;

var fromEntries = function fromEntries(entries) {
  return entries.reduce(function (carry, _ref) {
    var key = _ref[0],
        value = _ref[1];
    carry[key] = value;
    return carry;
  }, {});
};

exports.fromEntries = fromEntries;
//# sourceMappingURL=object.js.map