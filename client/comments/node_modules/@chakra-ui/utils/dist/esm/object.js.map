{"version":3,"sources":["../../src/object.ts"],"names":["memoizeOne","default","merge","mergeWith","objectAssign","omit","object","keys","result","key","includes","pick","split","picked","omitted","get","obj","path","fallback","index","length","undefined","memoizedGet","getWithDefault","scale","objectFilter","fn","value","shouldPass","filterUndefined","val","objectKeys","Object","fromEntries","entries","reduce","carry"],"mappings":"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","sourcesContent":["import memoizeOne from \"memoize-one\"\nimport type { Omit, Dict } from \"./types\"\nexport { default as merge } from \"lodash.merge\"\nexport { default as mergeWith } from \"lodash.mergewith\"\nexport { default as objectAssign } from \"object-assign\"\n\nexport function omit<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result: Dict = {}\n\n  for (const key in object) {\n    if (keys.includes(key as any)) continue\n    result[key] = object[key]\n  }\n\n  return result as Omit<T, K>\n}\n\nexport function pick<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result = {} as { [P in K]: T[P] }\n  for (const key of keys) {\n    if (key in object) {\n      result[key] = object[key]\n    }\n  }\n  return result\n}\n\nexport function split<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const picked: Dict = {}\n  const omitted: Dict = {}\n\n  for (const key in object) {\n    if (keys.includes(key as T[K])) {\n      picked[key] = object[key]\n    } else {\n      omitted[key] = object[key]\n    }\n  }\n\n  return [picked, omitted] as [{ [P in K]: T[P] }, Omit<T, K>]\n}\n\n/**\n * Get value from a deeply nested object using a string path\n * @param obj - the object\n * @param path - the string path\n * @param def  - the fallback value\n */\nexport function get(\n  obj: any,\n  path: string | number,\n  fallback?: any,\n  index?: number,\n) {\n  //@ts-ignore\n  path = (path?.split?.(\".\") ?? [path]) as string\n  for (index = 0; index < path.length; index++) {\n    obj = obj ? obj[path[index]] : undefined\n  }\n  return obj === undefined ? fallback : obj\n}\n\n// Just a memoized version of `get`\nexport const memoizedGet = memoizeOne(get)\n\n/**\n * Get value from deeply nested object, based on path\n * It returns the path value if not found in object\n *\n * @param path - the string path or value\n * @param scale - the string path or value\n */\nexport function getWithDefault(path: any, scale: any) {\n  return get(scale, path, path)\n}\n\ntype FilterFn<T> = (value: any, key: string, object: T) => boolean\n\n/**\n * Returns the items of an object that meet the condition specified in a callback function.\n *\n * @param object the object to loop through\n * @param fn The filter function\n */\nexport function objectFilter<T extends Dict>(object: T, fn: FilterFn<T>) {\n  const result: Dict = {}\n\n  for (const key in object) {\n    const value = object[key]\n    const shouldPass = fn(value, key, object)\n\n    if (shouldPass) {\n      result[key] = value\n    }\n  }\n\n  return result\n}\n\nexport const filterUndefined = (object: Dict) =>\n  objectFilter(object, (val) => val !== null)\n\nexport const objectKeys = <T extends Dict>(obj: T) =>\n  (Object.keys(obj) as unknown) as (keyof T)[]\n\n/**\n * Object.entries polyfill for Nodev10 compatibility\n */\nexport const fromEntries = <T extends unknown>(entries: [string, any][]) =>\n  entries.reduce((carry, [key, value]) => {\n    carry[key] = value\n    return carry\n  }, {}) as T\n"],"file":"object.js"}