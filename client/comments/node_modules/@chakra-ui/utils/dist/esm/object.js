import memoizeOne from "memoize-one";
export { default as merge } from "lodash.merge";
export { default as mergeWith } from "lodash.mergewith";
export { default as objectAssign } from "object-assign";
export function omit(object, keys) {
  var result = {};

  for (var _key in object) {
    if (keys.includes(_key)) continue;
    result[_key] = object[_key];
  }

  return result;
}
export function pick(object, keys) {
  var result = {};

  for (var _key2 of keys) {
    if (_key2 in object) {
      result[_key2] = object[_key2];
    }
  }

  return result;
}
export function split(object, keys) {
  var picked = {};
  var omitted = {};

  for (var _key3 in object) {
    if (keys.includes(_key3)) {
      picked[_key3] = object[_key3];
    } else {
      omitted[_key3] = object[_key3];
    }
  }

  return [picked, omitted];
}
/**
 * Get value from a deeply nested object using a string path
 * @param obj - the object
 * @param path - the string path
 * @param def  - the fallback value
 */

export function get(obj, path, fallback, index) {
  var _path$split, _path;

  //@ts-ignore
  path = (_path$split = (_path = path) == null ? void 0 : _path.split == null ? void 0 : _path.split(".")) != null ? _path$split : [path];

  for (index = 0; index < path.length; index++) {
    obj = obj ? obj[path[index]] : undefined;
  }

  return obj === undefined ? fallback : obj;
} // Just a memoized version of `get`

export var memoizedGet = memoizeOne(get);
/**
 * Get value from deeply nested object, based on path
 * It returns the path value if not found in object
 *
 * @param path - the string path or value
 * @param scale - the string path or value
 */

export function getWithDefault(path, scale) {
  return get(scale, path, path);
}

/**
 * Returns the items of an object that meet the condition specified in a callback function.
 *
 * @param object the object to loop through
 * @param fn The filter function
 */
export function objectFilter(object, fn) {
  var result = {};

  for (var _key4 in object) {
    var _value = object[_key4];
    var shouldPass = fn(_value, _key4, object);

    if (shouldPass) {
      result[_key4] = _value;
    }
  }

  return result;
}
export var filterUndefined = object => objectFilter(object, val => val !== null);
export var objectKeys = obj => Object.keys(obj);
/**
 * Object.entries polyfill for Nodev10 compatibility
 */

export var fromEntries = entries => entries.reduce((carry, _ref) => {
  var [key, value] = _ref;
  carry[key] = value;
  return carry;
}, {});
//# sourceMappingURL=object.js.map